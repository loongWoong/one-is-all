<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PlantUML 在线渲染</title>
  <style>
    body{font-family:system-ui,Segoe UI,Arial;margin:18px}
    textarea{width:100%;height:240px;font-family:monospace;margin-bottom:8px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
    .output{border:1px solid #e5e7eb;padding:12px;position:relative}
    /* 图片容器 & 缩放视口 */
    #imageWrapper{width:100%;height:600px;border:1px solid #ddd;overflow:auto;background:#fff;position:relative}
    #imageInner{display:inline-block;transform-origin:0 0;will-change:transform}
    #imageInner img, #imageInner svg{display:block;max-width:none;height:auto;user-select:none}
    /* 鹰眼（minimap） - 固定在 imageWrapper 的右上角；作为 imageWrapper 的绝对定位子元素，不受 imageInner transform 影响 */
    #minimap{position:absolute;right:12px;top:12px;width:160px;height:120px;border:1px solid rgba(0,0,0,0.25);background:rgba(255,255,255,0.95);z-index:40;box-shadow:0 2px 6px rgba(0,0,0,0.12);overflow:hidden;transform:none}
    #minimap canvas{width:100%;height:100%;display:block}
    /* 仅移动和缩放视口指示框，minimap 本体固定不变 */
    #minimapRect{position:absolute;box-sizing:border-box;border:2px solid rgba(255,0,0,0.85);pointer-events:none;background:rgba(255,255,255,0.03)}
    button,select,input{padding:8px}
  </style>
</head>
<body>
  <h1>PlantUML 在线渲染（参考 PlantUML Server）</h1>
  <p>输入 PlantUML 源代码，选择输出格式，点击 <strong>渲染</strong> 获取图片与可分享链接。</p>

  <textarea id="uml" spellcheck="false">@startuml
Alice -> Bob: Hello
@enduml</textarea>

  <div class="controls">
    <select id="format">
      <option value="png">PNG</option>
      <option value="svg">SVG</option>
      <option value="txt">Plain text</option>
    </select>
    <div style="display:flex;gap:8px;align-items:center">
      <select id="serverPreset" style="padding:8px">
        <option value="custom">自定义...</option>
        <option value="http://192.168.22.212:8001">http://192.168.22.212:8001</option>
        <option value="https://www.plantuml.com/plantuml">https://www.plantuml.com/plantuml</option>
      </select>
      <input id="server" value="https://www.plantuml.com/plantuml" style="min-width:320px;flex:1" />
    </div>
    <button id="render">渲染</button>
    <button id="download">下载</button>
    <button id="copyLink">复制链接</button>
    <button id="copySource">复制源码</button>
  </div>

  <div class="output" id="output">
    <div id="linkContainer"></div>
    <div id="imageContainer" style="position:relative"></div>
    <pre id="textOutput" style="display:none;white-space:pre-wrap"></pre>
  </div>

  <!-- 使用 pako 做 deflate 压缩（动态加载以避免 pako 未定义错误） -->
  <script>
    function loadScript(src){
      return new Promise((res, rej)=>{
        const s = document.createElement('script');
        s.src = src;
        s.async = true;
        s.onload = () => res();
        s.onerror = () => rej(new Error('加载脚本失败: '+src));
        document.head.appendChild(s);
      });
    }

    async function ensurePako(){
      if (window.pako) return;
      // 尝试多个 CDN 加载 pako（顺序降级）
      const candidates = [
        'https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js',
        'https://unpkg.com/pako@2.1.0/dist/pako.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js'
      ];
      let lastErr = null;
      for (const url of candidates) {
        try {
          await loadScript(url);
          if (window.pako) return;
        } catch (e) {
          lastErr = e;
        }
      }
      // 浏览器环境可能限制外部脚本加载（离线或被拦截）
      throw new Error('pako 加载失败: ' + (lastErr && lastErr.message ? lastErr.message : 'unknown'));
    }

    // PlantUML 的 base64 字母表（自定义 64 字符）
    const encode64 = (data) => {
      const chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
      let res = '';
      let i = 0;
      while (i < data.length) {
        let b1 = data.charCodeAt(i++) & 0xff;
        if (i === data.length) { res += chars.charAt(b1 >> 2); res += chars.charAt((b1 & 0x3) << 4); res += '=='; break; }
        let b2 = data.charCodeAt(i++);
        if (i === data.length) {
          res += chars.charAt(b1 >> 2);
          res += chars.charAt(((b1 & 0x3) << 4) | ( (b2 & 0xF0) >> 4 ));
          res += chars.charAt((b2 & 0xF) << 2);
          res += '='; break;
        }
        let b3 = data.charCodeAt(i++);
        res += chars.charAt(b1 >> 2);
        res += chars.charAt(((b1 & 0x3) << 4) | ( (b2 & 0xF0) >> 4 ));
        res += chars.charAt(((b2 & 0xF) << 2) | ( (b3 & 0xC0) >> 6 ));
        res += chars.charAt(b3 & 0x3F);
      }
      return res;
    };

    // PlantUML 官方算法：先用 deflate 压缩，然后用自定义 64 编码
    async function plantuml_encode(text) {
      await ensurePako();
      // 转为 UTF-8 字节串
      const utf8 = new TextEncoder().encode(text);
      const deflated = pako.deflate(utf8, { level: 9, raw: true });
      let s = '';
      for (let i = 0; i < deflated.length; i++) s += String.fromCharCode(deflated[i]);
      return encode64(s);
    }

    const $ = id => document.getElementById(id);

    function buildUrl(serverBase, encoded, format) {
      serverBase = serverBase.replace(/\/+$/,'');
      if (format === 'txt') return serverBase + '/txt/' + encoded;
      if (format === 'svg') return serverBase + '/svg/' + encoded;
      return serverBase + '/png/' + encoded;
    }

    async function render() {
      const source = $('uml').value;
      const format = $('format').value;
      const server = $('server').value || 'http://192.168.22.212:8001';
      try {
        const encoded = await plantuml_encode(source);
        const url = buildUrl(server, encoded, format);
        const linkHtml = `
          <div>可分享链接：
            <a href="${url}" target="_blank" 
               style="display:inline-block;max-width:70vw;vertical-align:bottom;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">
               ${url}
            </a>
          </div>`;
        $('linkContainer').innerHTML = linkHtml;
        $('copyLink').dataset.url = url;

            if (format === 'txt') {
          const res = await fetch(url);
          const txt = await res.text();
          $('textOutput').style.display = 'block';
          $('textOutput').textContent = txt;
          $('imageContainer').innerHTML = '';
        } else if (format === 'svg') {
          const res = await fetch(url);
          const svg = await res.text();
          $('textOutput').style.display = 'none';
          // 包裹 imageWrapper 并注入 svg
          // 将 minimap 放在 imageContainer（非滚动父级），使其不随 imageWrapper 滚动移动
          $('imageContainer').innerHTML = `
            <div id="imageWrapper">
              <div id="imageInner">${svg}</div>
            </div>
            <div id="minimap"><canvas></canvas><div id="minimapRect"></div></div>
          `;
          initImageInteractions();
        } else {
          $('textOutput').style.display = 'none';
          $('imageContainer').innerHTML = `
            <div id="imageWrapper">
              <div id="imageInner"><img src="${url}" alt="PlantUML" /></div>
            </div>
            <div id="minimap"><canvas></canvas><div id="minimapRect"></div></div>
          `;
          initImageInteractions();
        }
      } catch (e) {
        $('imageContainer').innerHTML = `<pre style="color:red">渲染失败：${e.message}</pre>`;
      }
    }

    document.addEventListener('DOMContentLoaded', ()=>{
      document.getElementById('render').addEventListener('click', () => { render(); });
      // preset select behavior
      const preset = document.getElementById('serverPreset');
      const serverInput = document.getElementById('server');
      preset.addEventListener('change', ()=>{
        if (preset.value === 'custom') { serverInput.focus(); return; }
        serverInput.value = preset.value;
      });
      // keep preset in sync when user types
      serverInput.addEventListener('input', ()=>{
        if (serverInput.value === 'http://192.168.22.212:8001' || serverInput.value === 'https://www.plantuml.com/plantuml') {
          preset.value = serverInput.value;
        } else {
          preset.value = 'custom';
        }
      });

      document.getElementById('download').addEventListener('click', async () => {
        const url = document.getElementById('copyLink').dataset.url;
        if (!url) { alert('请先渲染以生成链接'); return; }
        const format = document.getElementById('format').value;
        try {
          const res = await fetch(url);
          const blob = await res.blob();
          const a = document.createElement('a');
          const ext = format === 'svg' ? 'svg' : format === 'txt' ? 'txt' : 'png';
          a.href = URL.createObjectURL(blob);
          a.download = 'diagram.' + ext;
          document.body.appendChild(a);
          a.click();
          a.remove();
        } catch (e) { alert('下载失败：' + e.message); }
      });

      document.getElementById('copyLink').addEventListener('click', async () => {
        const url = document.getElementById('copyLink').dataset.url;
        if (!url) { alert('请先渲染以生成链接'); return; }
        await navigator.clipboard.writeText(url);
        alert('链接已复制到剪贴板');
      });

      document.getElementById('copySource').addEventListener('click', async () => {
        await navigator.clipboard.writeText(document.getElementById('uml').value);
        alert('源码已复制到剪贴板');
      });

      // 初次渲染
      render();
    });

    // ---- 图片交互：Ctrl+滚轮缩放 + 鹰眼 ----
    function initImageInteractions(){
      const wrapper = document.getElementById('imageWrapper');
      const inner = document.getElementById('imageInner');
      const minimap = document.getElementById('minimap');
      const canvas = minimap.querySelector('canvas');
      const rect = document.getElementById('minimapRect');
      if (!wrapper || !inner) return;
      let scale = 1; // 当前缩放比例
      function updateTransform(){ inner.style.transform = 'scale(' + scale + ')'; updateMinimap(); }
      // Ctrl+wheel 缩放
      wrapper.addEventListener('wheel', (e)=>{
        if (!e.ctrlKey) return; e.preventDefault();
        const delta = -e.deltaY;
        const factor = delta > 0 ? 1.1 : 0.9;
        const old = scale; scale = Math.max(0.1, Math.min(8, scale * factor));
        // 为了更好地聚焦鼠标位置，我们调整 wrapper.scrollLeft/Top
        const rectWrap = wrapper.getBoundingClientRect();
        const mx = e.clientX - rectWrap.left + wrapper.scrollLeft;
        const my = e.clientY - rectWrap.top + wrapper.scrollTop;
        const rx = mx / old; const ry = my / old;
        const nx = rx * scale; const ny = ry * scale;
        wrapper.scrollLeft = Math.max(0, nx - (e.clientX - rectWrap.left));
        wrapper.scrollTop = Math.max(0, ny - (e.clientY - rectWrap.top));
        updateTransform();
      }, { passive: false });

      // 支持鼠标左键拖动平移（在 imageWrapper 内拖动会改变 scroll）
      let isDragging = false; let startX = 0; let startY = 0; let startScrollLeft = 0; let startScrollTop = 0;
      wrapper.addEventListener('mousedown', (e)=>{
        // 只响应左键且不在 minimap 上
        if (e.button !== 0) return;
        const mm = minimap.getBoundingClientRect();
        const pt = {x: e.clientX, y: e.clientY};
        if (pt.x >= mm.left && pt.x <= mm.right && pt.y >= mm.top && pt.y <= mm.bottom) return;
        isDragging = true; startX = e.clientX; startY = e.clientY; startScrollLeft = wrapper.scrollLeft; startScrollTop = wrapper.scrollTop;
        document.body.style.cursor = 'grabbing'; e.preventDefault();
      });
      window.addEventListener('mousemove', (e)=>{
        if (!isDragging) return;
        const dx = e.clientX - startX; const dy = e.clientY - startY;
        wrapper.scrollLeft = Math.max(0, startScrollLeft - dx);
        wrapper.scrollTop = Math.max(0, startScrollTop - dy);
        updateMinimap();
      });
      window.addEventListener('mouseup', (e)=>{ if (isDragging) { isDragging = false; document.body.style.cursor=''; } });

      // 绘制 minimap
      function updateMinimap(){
        try{
          // 固定缩略图尺寸（与 CSS 保持一致）
          const mapW = minimap.clientWidth; const mapH = minimap.clientHeight;
          canvas.width = Math.round(mapW * devicePixelRatio);
          canvas.height = Math.round(mapH * devicePixelRatio);
          canvas.style.width = mapW + 'px'; canvas.style.height = mapH + 'px';
          const ctx = canvas.getContext('2d');
          ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
          ctx.clearRect(0,0,mapW,mapH);

          const fullW = inner.offsetWidth * scale; const fullH = inner.offsetHeight * scale;
          const imgEl = inner.querySelector('img');

          // 计算把整个缩放后的图像按比例绘制到 minimap 中的缩放系数
          const fitScale = Math.min(mapW / fullW, mapH / fullH);
          const drawW = fullW * fitScale; const drawH = fullH * fitScale;
          const offsetX = (mapW - drawW) / 2; const offsetY = (mapH - drawH) / 2;

          if (imgEl && imgEl.naturalWidth){
            // drawImage 支持将原始图像绘制到缩略图上；对于 SVG，浏览器可能不允许直接 drawImage
            try{
              ctx.drawImage(imgEl, 0, 0, inner.offsetWidth, inner.offsetHeight, offsetX, offsetY, drawW, drawH);
            }catch(err){
              // 如果绘制失败（SVG 跨域/不受支持），退回为占位背景
              ctx.fillStyle = '#f8f8f8'; ctx.fillRect(offsetX,offsetY,drawW,drawH);
            }
          } else {
            ctx.fillStyle = '#f8f8f8'; ctx.fillRect(offsetX,offsetY,drawW,drawH);
            ctx.strokeStyle = '#eee';
            for(let x=0;x<drawW;x+=20) { ctx.beginPath(); ctx.moveTo(offsetX+x,offsetY); ctx.lineTo(offsetX+x,offsetY+drawH); ctx.stroke(); }
            for(let y=0;y<drawH;y+=20) { ctx.beginPath(); ctx.moveTo(offsetX,offsetY+y); ctx.lineTo(offsetX+drawW,offsetY+y); ctx.stroke(); }
          }

          // 计算并绘制表示当前可视区域的矩形（基于 scroll）
          const vw = wrapper.clientWidth; const vh = wrapper.clientHeight;
          const left = wrapper.scrollLeft; const top = wrapper.scrollTop;
          const viewLeft = offsetX + left * fitScale / scale;
          const viewTop = offsetY + top * fitScale / scale;
          const viewW = Math.max(8, vw * fitScale / scale);
          const viewH = Math.max(8, vh * fitScale / scale);
          rect.style.width = viewW + 'px';
          rect.style.height = viewH + 'px';
          rect.style.left = viewLeft + 'px';
          rect.style.top = viewTop + 'px';
        }catch(e){/* ignore */}
      }

      // sync scrolling
      wrapper.addEventListener('scroll', ()=>{ updateMinimap(); });
      // click on minimap to recenter
      minimap.addEventListener('click', (ev)=>{
        const rectM = minimap.getBoundingClientRect();
        const x = ev.clientX - rectM.left; const y = ev.clientY - rectM.top;
        const canvasW = canvas.width; const canvasH = canvas.height;
        const targetX = x / canvasW * inner.offsetWidth * scale - wrapper.clientWidth/2;
        const targetY = y / canvasH * inner.offsetHeight * scale - wrapper.clientHeight/2;
        wrapper.scrollLeft = Math.max(0, targetX);
        wrapper.scrollTop = Math.max(0, targetY);
        updateMinimap();
      });

      // initial
      scale = 1; updateTransform();
    }
  </script>
</body>
</html>